from pyrogram import *  # импорт всего из библиотеки для работы с юзерботом
from settings import *  # импортируем данные из файла settings
import datetime as dt  # импортируем библиотеку для получения данных о времени на устройствеы
import pickledb as DB  # импортируем библиотеку для создания примитивной базы данных
from random import randint  # импорт функции выдачи рандомных (по заданному ограничению) чисел (для рандомной доп-задержки)
from time import sleep  # импорт функции засыпания программы

app = Client("my_account", api_id=int(api_id), api_hash=api_hash)  # создаем профиль для юзербота

msgs = 0  # еременная в которой в будущем будет храниться количество отправленных сообщений

def main():  # основная функция
    names = []  # список в котором будут храниться имена

    def join_in_chat(link):  # функция для входа в чат
        try:  # проверка на наличие ошибок
            app.join_chat(link)  # входим в чат по ссылке
            print(f"Вы вошли в чат {app.get_chat(link).title}")  # пишет в какой чат мы зашли
        except errors.exceptions.flood_420.FloodWait:  # если произошла ошибка от того что вы есть в чате то
            pass  # null функция, что бы ничего не происходило
        except errors.exceptions.bad_request_400.UserAlreadyParticipant:  # если произошла ошибка от того что вы есть в чате то
            pass  # null функция, что бы ничего не происходило

    def getnames():  # функция для получения имени (ссылки) всех пользователей в чате
        with app:  # начинаем работу с юзерботом
            for link in chats:  # проходим по списку id чатов
                join_in_chat(link)  # запуск функции для входа в чат
                id = app.get_chat(link).id  # id группы
                if -100 in id:  # проверяем есть ли -100 у id
                    for user in app.get_chat_members(app.get_chat(link).id):  # берем профили пользователей из группы
                        names.append(user.user.username)  # берем имя пользователя и добавляем его в список
                else:  # если нет то
                    for user in app.get_chat_members(int(f"-100{str(id)}")):  # берем профили пользователей из группы по id и добавляем -100
                        names.append(user.user.username)  # берем имя пользователя и добавляем его в список
        return names  # возвращаем список имен

    names = set(getnames())  # вписываем в переменную names ( уникальный с помощью set() ) список имен который вернула функция getnames

    print(f"Сообщение должно будет быть отправлено следующим пользователям: @{' @'.join(names)}!")  # пишем кому будут отправлены сообщения

    def sender():  # функция отправки сообщений
        global is_block, msgs
        try:  # проверка на наличие ошибок
            db = DB.load("block_time.txt", True)  # записывает базу данных в переменную
            hour = int(dt.datetime.now().hour)  # переменная для того что бы знать сколько сейчас часов
            day = int(dt.datetime.now().day)  # переменная для того что бы знать какой сейчас день

            if msgs >= int(max_users):  # если количество отправленных сообщений больше чем max_users (ограничение) то
                db.set("is_block", True)  # записывет в переменную is_block True (включено в данном случае)

            if str(db.getall()) == "dict_keys([])":  # если бд пустая (или отсутствует) то
                    db.set("hour", hour)  # создаем бд и вписываем время (часы) (на 8 часов меньше чем текущие что бы сработал "первый запуск")
                    db.set("day", day)  # создаем бд и вписываем день
                    db.set("is_block", False)  # ставит is_block в состояние False (выключено в данном случае)

            if db.get("is_block"):  # если is_block или is_block из бд равно true (включить в данном случае) то
                if hour - int(max_users_timing) >= db.get("hour") or db.get("day") != day:  # если текущий час на 8 часов больше тому что записан в бд или наступил след. день относительно того что записан в бд то
                    print("Unblock!")  # пишет что вы разблокированы
                    db.set("is_block", False)  # ставит is_block в состояние False (выключено в данном случае)
                    msgs = 0  # сбрасывает количество отправленных сообщений
                    db.set("hour", hour)  # обновляем данные часа в бд на текущие
                    db.set("day", day)  # обновляем данные про день в бд на текущие

            else:  # а если is_block НЕ равно true то

                with app:  # начинаем работу с юзерботом
                    for name in names:  # перебор имен из соответствующего списка
                        db = DB.load(f"../users/{name}.txt", True)  # загружаем файл (бд) с названием соответствующим имени пользователя (для удобства) и записываем в переменную
                        if str(db.getall()) == "dict_keys([])":  # если бд пустая (или отсутствует) то
                            db.set("hour", hour - 8)  # создаем бд и вписываем время (часы) (на 8 часов меньше чем текущие что бы сработал "первый запуск")
                            db.set("day", day)  # создаем бд и вписываем день

                        if hour - int(timing) >= db.get("hour"):  # если текущий час на 8 часов больше тому что записан в бд то
                            msgs += 1  # прибаляет 1 в переменную max_users
                            app.send_message(f"@{name}", message)  # отправка сообщения
                            db.set("hour", hour)  # обновляем данные часа в бд на текущие
                            db.set("day", day)  # обновляем данные про день в бд на текущие
                            print(f"Сообщение отправлено пользователю @{name}!")  # пишем кому отправлено сообщение

                        elif db.get("day") != day:  # если наступил след. день относительно того что записан в бд то
                            msgs += 1  # прибаляет 1 в переменную max_users
                            app.send_message(f"@{name}", message)  # отправка сообщения
                            db.set("hour", hour)  # обновляем данные часа в бд на текущие
                            db.set("day", day)  # обновляем данные про день в бд на текущие
                            print(f"Сообщение отправлено пользователю @{name}!")  # пишем кому отправлено сообщение

        except Exception as ex:  # обработка ошибки
            print(f'Ошибка: "{ex}"')  # пишем ошибку


    while True:  # вечный цикл
        sender()  # запуск функции отправки сообщений
        sleep( randint(0, 10) )  # засыпание программы на рандомное (от 0 до 10) секунд


main()  # запуск основной функции
